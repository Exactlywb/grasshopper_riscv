#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include "config.h"
#include "grasshopper/grasshopper.h"
#include "file_common.h"
#include "bmp_header.h"

bool import_key(Key* key, const char* key_file);
enum cipher_mode get_encryption_mode(const char* mode);

int main (int argc, char **argv)
{
  /* Now we should also pass key file, that could be generated by
     generation/KeyGeneration.py.  */
  if (argc != 6 && argc != 8)
  {
    fprintf (stderr, "Usage: ./grasshopper file_mode encryption_mode test_file"
		     " key_file iv_file [output_img_cipher, output_img_orig]\n");
    return _EXIT_CODE;
  }

  bool img_mode = false;
  if (strlen(argv[1]) != 1) {
    fprintf (stderr, "Enter file mode: b for bitmap image, t for text image\n");
  }

  if (argv[1][0] == 'b')
    img_mode = true;
  else if (argv[1][0] == 't')
    img_mode = false;
  else
    fprintf (stderr, "Enter file mode: b for bitmap image, t for text image\n");

  enum cipher_mode c_mode = get_encryption_mode(argv[2]);
  if (c_mode == NOMODE) {
    fprintf (stderr, "Enter cipher mode: one of ECB, CBC, PCBC, CFB, OFB\n");
    return _EXIT_CODE;
  }

  FILE *input;
  if (!(input = fopen (argv [3], "r")))
  {
    fprintf (stderr, "Can't open %s test\n", argv [1]);
    return _EXIT_CODE;
  }

  size_t file_size = get_file_size (input);
  size_t read_useful_size = file_size;

  BMPHeader head1 = {};

  if (img_mode) {
    input = read_bmp_header(&head1, input);
   read_useful_size  = file_size = file_size - sizeof(head1);
  }

  Block *buffer = (Block *)allocate_with_padding
		    (file_size, BLOCK_SIZE, &file_size);
  fread (buffer, sizeof (char), read_useful_size, input);

  Key key;
  if (!import_key(&key, argv[4])) {
    return _EXIT_CODE;
  }
  Key descrypt_key = key;

  Key key_iv;
  if (!import_key(&key_iv, argv[5])) {
    return _EXIT_CODE;
  }

  Block iv = key_iv.first;

  const long n_blocks = file_size / BLOCK_SIZE;
  encryption_driver(c_mode, buffer, &key, &iv, n_blocks);
  if (!img_mode) {
    for (size_t block_ind = 0; block_ind < n_blocks; ++block_ind)
    {
#if 1
      fprintf (stdout, "Running %ld/%ld block: ", block_ind, n_blocks);
      for (int i = 0; i < BLOCK_SIZE; ++i)
        fprintf (stdout, "%c", (buffer + block_ind)->data [i]);
      fprintf (stdout, "\n");
#endif
    }
  }

  char* cipher_img = "img_output_cipher.bmp";
  char* orig_img = "img_output_orig.bmp";

  if (img_mode && argc == 8) {
    cipher_img = argv[6];
    orig_img = argv[7];
  }

  if (img_mode) {
    FILE* output = fopen(cipher_img, "w");
    if (!output)
      return _EXIT_CODE;
    output = write_bmp_header(&head1, output);
    fwrite(buffer, sizeof(char), read_useful_size, output);
    fclose(output);
  }

  decryption_driver(c_mode, buffer, &descrypt_key, &iv, n_blocks);
  if (!img_mode) {
    for (size_t block_ind = 0; block_ind < n_blocks; ++block_ind)
    {
#if 1
      fprintf (stdout, "Running %ld/%ld block: ", block_ind, n_blocks);
      for (int i = 0; i < BLOCK_SIZE; ++i)
        fprintf (stdout, "%c", (buffer + block_ind)->data [i]);
      fprintf (stdout, "\n");
#endif
    }
  }
  fclose (input);

  if (img_mode) {
    FILE* output = fopen(orig_img, "w");
    if (!output)
      return _EXIT_CODE;

    output = write_bmp_header(&head1, output);
    fwrite(buffer, sizeof(char), read_useful_size, output);
    fclose(output);
  }

  free (buffer);

  return 0;
}

bool import_key(Key* key, const char* key_file) {
  FILE *input;
  if (!(input = fopen(key_file, "r")))
  {
      fprintf (stderr, "Can't open %s test\n", key_file);
      return false;
  }

  // Firstly we read first 16 bytes. That will form first key block
  fread(key->first.data, sizeof(char), BLOCK_SIZE, input);
  // Now we need to read last 16 bytes to form second key block.
  // To do it we make an offset and set file pointer.
  fseek(input, BLOCK_SIZE, SEEK_SET);
  fread(key->second.data, sizeof(char), BLOCK_SIZE, input);
  fclose(input);
  return true;
}

enum cipher_mode get_encryption_mode(const char* mode) {
  if (strlen(mode) == 3) {
    if(strcmp(mode, "ECB") == 0)
      return ECB;

    if(strcmp(mode, "CBC") == 0)
      return CBC;

    if(strcmp(mode, "CFB") == 0)
      return CFB;

    if(strcmp(mode, "OFB") == 0)
      return OFB;
  }

  if (strlen(mode) == 4)
    if(strcmp(mode, "PCBC") == 0)
      return PCBC;

  return NOMODE;
}
