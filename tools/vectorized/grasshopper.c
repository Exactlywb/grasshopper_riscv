#include "grasshopper/grasshopper.h"

#include <riscv_vector.h>

#include <string.h>
#include <stdio.h>

static void encrypt_block(Block *, Key *key);

static void generate_keys (Keys_Array keys, Key *key);

static void apply_f (Block *first, Block *second, const Block *key);
static void apply_l (Block *block);
static void apply_x (Block *block, const Block *key);
static void apply_ls (Block *block);
static void apply_xsl (Block *block, const Block *key);

//TODO: remove it with autogenerated tables
static void generate_mul_tbl ();
static void generate_coef_tbl ();
static void generate_LS_tbl ();

//TODO: autogenerate this and move to config.h
Block Coefs [NUM_ROUNDS / 2 - 1] [BIT_IN_BYTES];
unsigned char Muls [256] [16];
unsigned char LS_tbl [16] [256] [16];

void grasshopper_encrypt(Block *block, Key *key)
{
  //TODO: remove it with autogenerating for tables
  static int generate = 1;
  if (generate)
  {
    generate_mul_tbl ();
    generate_coef_tbl ();
    generate_LS_tbl ();
    generate = 0;
  }

  encrypt_block (block, key);
  apply_x (&key->first, block);
  apply_x (&key->second, block);
}

static void encrypt_block(Block *block, Key *key)
{
  Keys_Array keys;
  generate_keys (keys, key);

  for (int i = 0; i < NUM_ROUNDS - 1; ++i)
    apply_xsl (block, &keys [i]);

  apply_x (block, &keys [NUM_ROUNDS - 1]);
}

static void generate_keys (Keys_Array keys, Key *key)
{
  keys [0] = key->first;
  keys [1] = key->second;

  for (int i = 1; i < NUM_ROUNDS / 2; ++i)
  {
    keys [2 * i + 0] = keys [2 * i - 2];
    keys [2 * i + 1] = keys [2 * i - 1];
    for (int j = 0; j < BIT_IN_BYTES; ++j)
      apply_f (&keys [2 * i], &keys [2 * i + 1], &Coefs [i - 1] [j]);
  }
}

static void
apply_x(Block *block, const Block *key)
{
  // XOR two 16-bytes arrays block->data and key->data.
  // The result puts into block->data
  unsigned vl = __riscv_vsetvl_e8m1(BLOCK_SIZE);
  vuint8m1_t v1 = __riscv_vle8_v_u8m1(block->data, vl);
  vuint8m1_t v2 = __riscv_vle8_v_u8m1(key->data, vl);
  vuint8m1_t vd;

  vd = __riscv_vxor_vv_u8m1(v1, v2, vl);
  __riscv_vse8_v_u8m1(block->data, vd, vl);
}

static void apply_l (Block *block)
{
  for (int i = 0; i < BLOCK_SIZE; ++i)
  {
    unsigned char tmp = 0;
    for (int j = 0; j < BLOCK_SIZE; ++j)
      tmp ^= Muls [block->data [j]] [j];

    /* Copy backward.  */
    for (int rev = BLOCK_SIZE - 1; rev > 0; --rev)
      block->data [rev] = block->data [rev - 1];

    block->data [0] = tmp;
  }
}

static void apply_f (Block *first, Block *second, const Block *key)
{
  Block tmp = *first;
  apply_xsl (&tmp, key);
  apply_x (&tmp, second);

  /* Shift them.  */
  *second = *first;
  *first = tmp;
}

static void apply_ls (Block *block)
{
  unsigned char tmp [16] = {0};
  for (int i = 0; i < BLOCK_SIZE; ++i)
    for (int j = 0; j < BLOCK_SIZE; ++j)
      tmp [j] ^= LS_tbl [i] [block->data [i]] [j];
  
  // memcpy pattern (but better for RISCV!)
  unsigned vl = __riscv_vsetvl_e8m1(BLOCK_SIZE);
  vuint8m1_t v_tmp = __riscv_vle8_v_u8m1(tmp, vl);
  __riscv_vse8_v_u8m1(block->data, v_tmp, vl);
}

static void apply_xsl (Block *block, const Block *key)
{
  apply_x (block, key);
  apply_ls (block);
}

/* Work-horse for generate_mul_tbl.  */
static unsigned char poly_mul (unsigned char left, unsigned char right)
{
  /* p(x) = x**8 + x**7 + x**6 + x + 1:
       0b111000011 = 0x1C3

     with no MSB: 0xC3.  */
  unsigned char ret = 0;
  while (left && right)
  {
    if (right & 1)
      ret ^= left;

    left = (left << 1) ^ (left & 0x80 ? 0xC3 : 0x00);
    right >>= 1;
  }

  return ret;
}

/* Pregenerations.  */
static __attribute__((noinline)) void generate_mul_tbl ()
{
  for (int i = 0; i < 256; ++i)
    for (int j = 0; j < 16; ++j)
      Muls [i] [j] = poly_mul (i, lin [j]);
}

static __attribute__((noinline)) void generate_coef_tbl ()
{
  for (int i = 0; i < NUM_ROUNDS / 2 - 1; ++i)
    for (int j = 0; j < BIT_IN_BYTES; ++j)
    {
      Block *c = &Coefs [i] [j];
      memset (c, 0, BLOCK_SIZE);
      c->data [BLOCK_SIZE - 1] = i * 8 + j + 1;
      apply_l (c);
    }
}

static __attribute__((noinline)) void generate_LS_tbl ()
{
#define MATR_POWER 4
  unsigned char l_tbl [BLOCK_SIZE] [BLOCK_SIZE] = {0};

  /* Init matrix.  */
  for (int i = 0; i < BLOCK_SIZE; ++i)
    for (int j = 0; j < BLOCK_SIZE; ++j)
      if (i - 1 == j)
	l_tbl [i] [j] = 1;
      else if (i == 0)
	l_tbl [i] [j] = lin [j];

  /* Powering the matrix.  */
  unsigned char tmp [BLOCK_SIZE] [BLOCK_SIZE] = {0};
  for (int p = 0; p < MATR_POWER; ++p)
  {
    for (int i = 0; i < BLOCK_SIZE; ++i)
      for (int j = 0; j < BLOCK_SIZE; ++j)
	for (int k = 0; k < BLOCK_SIZE; ++k)
	  tmp [i] [j] ^= poly_mul (l_tbl [i] [k], l_tbl [k] [j]);

    memcpy (l_tbl, tmp, 256 * sizeof (unsigned char));
    memset (tmp, 0, 256 * sizeof (unsigned char));
  }

  for (int i = 0; i < BLOCK_SIZE; ++i)
    for (int j = 0; j < 256; ++j)
      for (int k = 0; k < BLOCK_SIZE; ++k)
	LS_tbl [i] [j] [k] ^= poly_mul (S [j], l_tbl [k] [i]);
}


void block_dump (const Block *block)
{
  for (int i = 0; i < BLOCK_SIZE; ++i)
    printf ("%c", block->data [i]);

  printf ("\n");
}

