#include "grasshopper/grasshopper.h"

#include <string.h>
#include <stdio.h>

static void encrypt_block(Block *, Key key);

static void generate_keys (Keys_Array keys, Key key);

static void apply_f (Block *first, Block *second, const Block *key);
static void apply_l (Block *block);
static void apply_x (Block *block, const Block *key);
static void apply_ls (Block *block);
static void apply_xsl (Block *block, const Block *key);

//TODO: remove it with autogenerated tables
static void generate_mul_tbl ();
static void generate_coef_tbl ();
static void generate_LS_tbl ();

//TODO: autogenerate this and move to config.h
Block Coefs [NUM_ROUNDS / 2 - 1] [BIT_IN_BYTES];
unsigned char Muls [256] [16];
unsigned char LS_tbl [16] [256] [16];

void grasshoper_encrypt(Block *block, Key key)
{
  //TODO: remove it with autogenerating for tables
  static int generate = 1;
  if (generate)
  {
    generate_mul_tbl ();
    generate_coef_tbl ();
    generate_LS_tbl ();
    generate = 0;
  }

  encrypt_block (block, key);
  apply_x (block, (Block *)key);
  apply_x (block, (Block *)(key + BLOCK_SIZE));
}

static void
apply_x(Block *block, const Block *key)
{
  for (int i = 0; i < BLOCK_SIZE; ++i)
    block->data [i] = block->data [i] ^ key->data [i];
}

static void encrypt_block(Block *block, Key key)
{
  Keys_Array keys;
  generate_keys (keys, key);

  for (int i = 0; i < NUM_ROUNDS - 1; ++i)
    apply_xsl (block, &keys [i]);

  apply_x (block, &keys [NUM_ROUNDS - 1]);
}

static void generate_keys (Keys_Array keys, Key key)
{
  keys [0] = *((Block *)((unsigned char *)key + 0 * BLOCK_SIZE));
  keys [1] = *((Block *)((unsigned char *)key + 1 * BLOCK_SIZE));

  for (int i = 1; i < NUM_ROUNDS / 2; ++i)
  {
    keys [2 * i + 0] = keys [2 * i - 2];
    keys [2 * i + 1] = keys [2 * i - 1];
    for (int j = 0; j < BIT_IN_BYTES; ++j)
      apply_f (&keys [2 * i], &keys [2 * i + 1], &Coefs [i - 1] [j]);
  }
}

static void apply_l (Block *block)
{
  for (int i = 0; i < BLOCK_SIZE; ++i)
  {
    unsigned char tmp = 0;
    for (int j = 0; j < BLOCK_SIZE; ++j)
      tmp ^= Muls [block->data [j]] [j];

    /* Copy backward.  */
    for (int rev = BLOCK_SIZE - 1; rev > 0; --rev)
      block->data [rev] = block->data [rev - 1];

    block->data [0] = tmp;
  }
}

static void apply_f (Block *first, Block *second, const Block *key)
{
  Block tmp = *first;
  apply_xsl (&tmp, key);
  apply_x (&tmp, second);

  /* Swap them.  */
  *second = *first;
  *first = tmp;
}

static void apply_ls (Block *block)
{
  unsigned char tmp [16] = {0};
  for (int i = 0; i < BLOCK_SIZE; ++i)
    for (int j = 0; j < BLOCK_SIZE; ++j)
      tmp [j] ^= LS_tbl [i] [block->data [i]] [j];

  for (int i = 0; i < BLOCK_SIZE; ++i)
    block->data [i] = tmp [i];
}

static void apply_xsl (Block *block, const Block *key)
{
  apply_x (block, key);
  apply_ls (block);
}

/* Work-horse for generate_mul_tbl.  */
static unsigned char poly_mul (unsigned char left, unsigned char right)
{
  /* p(x) = x**8 + x**7 + x**6 + x + 1:
       0b111000011 = 0x1C3

     with no MSB: 0xC3.  */
  unsigned char ret = 0;
  while (left && right)
  {
    if (right & 1)
      ret ^= left;

    left = (left << 1) ^ (left & 0x80 ? 0xC3 : 0x00);
    right >>= 1;
  }

  return ret;
}

/* Pregenerations.  */
static void generate_mul_tbl ()
{
  for (int i = 0; i < 256; ++i)
    for (int j = 0; j < 16; ++j)
      Muls [i] [j] = poly_mul (i, lin [j]);
}

static void generate_coef_tbl ()
{
  for (int i = 0; i < NUM_ROUNDS / 2 - 1; ++i)
    for (int j = 0; j < BIT_IN_BYTES; ++j)
    {
      Block *c = &Coefs [i] [j];
      memset (c, 0, BLOCK_SIZE);
      ((unsigned char *)c) [BLOCK_SIZE - 1] = i * 8 + 1;
      apply_l (c);
    }
}

static void generate_LS_tbl ()
{
#define MATR_POWER 4
  unsigned char l_tbl [BLOCK_SIZE] [BLOCK_SIZE];

  /* Init matrix.  */
  for (int i = 0; i < BLOCK_SIZE; ++i)
    for (int j = 0; j < BLOCK_SIZE; ++j)
      if (i - 1 == j)
	l_tbl [i] [j] = 1;
      else if (i == 0)
	l_tbl [i] [j] = lin [j];

  /* Powering the matrix.  */
  unsigned char tmp [BLOCK_SIZE] [BLOCK_SIZE];
  for (int p = 0; p < MATR_POWER; ++p)
  {
    for (int i = 0; i < BLOCK_SIZE; ++i)
      for (int j = 0; j < BLOCK_SIZE; ++j)
	for (int k = 0; k < BLOCK_SIZE; ++k)
	  tmp [i] [j] ^= poly_mul (l_tbl [i] [k], l_tbl [k] [j]);

    memcpy (l_tbl, tmp, 256 * sizeof (unsigned char));
    memset (tmp, 0, 256 * sizeof (unsigned char));
  }

  for (int i = 0; i < BLOCK_SIZE; ++i)
    for (int j = 0; j < 256; ++j)
      for (int k = 0; k < BLOCK_SIZE; ++k)
	LS_tbl [i] [j] [k] ^= poly_mul (S [j], l_tbl [k] [i]);
}

