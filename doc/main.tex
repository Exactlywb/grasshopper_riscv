\documentclass[a4paper, 12pt]{article}

\input{./include/preambule.tex}

\begin{document}
    \input{./include/title.tex}

    \section{Abstract}
    Для современных компьютерных систем важно, чтобы алгоритмы шифрования данных были не
    только надежными, но так же быстрыми с точки зрения вычислительных операций. В
    данной статье мы опишем векторную реализацию блочного шифра <<Кузнечик>> для 
    процессорной архитектуры RISC-V, а так же сравним скорость ее работы с 
    последовательной реализацией и векторной реализацией на других архитектурах.

    \section{Введение}

    В современном мире, где довольно значительную роль играют цифровые технологии,
    криптография является довольно важной частью обеспечения безопасности в цифровой
    среде. Защита интернет-соединений и каналов связи, надежность проведения банковских
    операций, подтверждение подлинности электронных документов. Современные методы
    защиты информации накладывают большое количество требований на современные 
    алгоритмы шифрования, такие как теоретическая и вычислительная криптостойкость, а 
    так же скорость работы.
    
    Для современных компьютерных систем важно, чтобы алгоритмы шифрования данных были не
    только надежными, но так же быстрыми с точки зрения вычислительных операций. На 
    сегодняшний день одним из популярных способов увеличения скорости работы программ
    является векторизация математических операций. Данный способ основывается на 
    принципе компьютерных вычислений SIMD (анг. single instruction multiple data), 
    позволяющем обеспечить параллелизм на уровне данных. И хотя, данный вид
    оптимизации требует индивидуальной реализации для разных архитектур, он является
    довольно мощным в плане увеличения производительности кода. Кроме того, векторизацию
    удобно использовать в алгоритмах с большим количеством однотипных математических
    операций, в частности, в алгоритмах блочного шифрования.

    В данной статье мы опишем векторную реализацию блочного шифра <<Кузнечик>> для 
    процессорной архитектуры RISC-V, а так же сравним скорость ее работы с 
    последовательной реализацией и векторной реализацией на других архитектурах.

    \section{Шифр <<Кузнечик>>}

    Алгоритм шифрования <<Кузнечик>> является одним из двух шифров, принятых в 2015 г.
    в России в стандарт блочного шифрования ГОСТ Р 34.12-2015. <<Кузнечик>> относится
    к типу блочных симметричных шифров; это значит, что для зашифрования и
    расшифрования используется один и тот же ключ, и что при шифровании исходный текст
    разделяется на блоки фиксированной длины, каждый из которых шифруется отдельно.

    На сегодняшний день, шифр все еще считается криптостойким.

    \section{Математическое описания шифра <<Кузнечик>>}

    \subsection{SP-сети}

    \subsection{Ячейка Фейстеля}

    \subsection{<<Кузнечик>>}

    Непосредственно алгоритм шифрования <<Кузнечик>> основан на SP-сети, а не на ячейке 
    Фейстеля. Как и другие популярные шифры, <<Кузнечик>> является блочным итеративным 
    шифром, а это значит, что для каждой итерации необходимо генерировать отдельный 
    \textbf{итеративный ключ} на основе исходного \textbf{мастер-ключа}. Здесь и
    нашла свое применение \textbf{ячейка Фейстеля}. Принцип ячейки Фейстеля используется
    для генерации итеративных ключей.

    Подведем промежуточный итог -- обозначим последовательность действий в алгоритме 
    шифрования:

    \begin{enumerate}
        \item На вход алгоритма подается исходный открытый текст $M$.
%TODO:  Этот текст разбивается на блоки $M_i$ по 128 бит
        \item Этот текст разбивается на блоки по 128 бит $M_i$ (если размер исходного текста не кратен 128, то он дополняется до нужного размера с помощью заранее оговоренной последовательности).
        \item Полученные блоки начинают обрабатываться итеративно. После обработки всех блоков исходного текста, мы получаем набор блоков шифротекста $C_i$.
        \item Полученные блоки шифротекста объединяются с помощью заранее обговоренного алгоритма (об этом будет сказано дальше), формируя итоговый шифротекст $C$.
    \end{enumerate}

    Так же, распишем более подробно этап итеративной обработки каждого блока, приведя
    набор действий, производящихся с одним блоком в каждой итерации.

    \begin{enumerate}
        \item На вход поступает блок открытого текста $M_i$ длинной 128 бит.
        \item Для текущей итерации с помощью ячейки Фейстеля генерируется раундовый ключ $K_i$ длинной 128 бит.
        \item Блок исходного текста и раундовый ключ складываются по модулю 2, образуя новый блок длинной 128 бит $B_i = M_i \oplus K_i$.
        \item К полученному блоку применяется затем нелинейное преобразование $S$, а затем линейное преобразование $L$, таким обращом получается блок шифротекста $C_i = L(S(B_i)) = L(S(M_i \oplus K_i))$.
    \end{enumerate}

    Блок-схема одной итерации, производящейся с блоком данных приведена на рис. \ref{fig:AlgorithBlockScheme}.

    \begin{figure}
        \centering
        \includegraphics{images/AlgorithBlockScheme.png}
        \caption{Один раунд шифрования в алгоритме <<Кузнечик>>}
        \label{fig:AlgorithBlockScheme}
    \end{figure}

    Опишем теперь суть нелинейного преобразования $S$, а так же линейного 
    преобразования $L$.

    \subsubsection{Нелинейное S-преобразование}

    На вход неленейному преобразованию поступает блок данных длинной 128 бит. Этот блок
    делится на 16 частей по 8 бит. Каждая 8-битовая часть интерпретируется, как целое 
    число $Int_8$, назовем его $a$. 

    \begin{proposition} \label{propos:a_is_8_bit}
    Число $a$ будет находиться в диапазоне от 0 до 255, поскольку является 8-битным 
    числом в двоичной записи.
    \end{proposition}

    В шифрующем алгоритме хранится заранее подготовленный массив из 256 констант. Каждое
    число $a$ выступает в качестве индекса в этом массиве. Заметим, что благодаря 
    утверждению \ref{propos:a_is_8_bit} число $a$ никогда не даст индекс, выходящий за
    границы массива констант. Значение по этому индксу преобразуется обратно в двоичное 
    число и является результатом работы блока нелинейного преобразования $S$.

    Приведем пример. \textbf{Внимание! Для удобства читателя в примерах все математические операции выполняются над полем целых чисел. В реальном алгоритме шифрования математические операции проводятся в поле Галуа $\mathbf{GF}(2^8)$ с модулем $p(x) = x^8 + x^7 + x^6 + x + 1$. В таком поле сложение производится по модулю 2, а умножение по модулю многочлена $p(x)$}

    %TODO: дописать пример
    \begin{example}

    Для удобства, в этом примере будем считать, что на вход нелинейного преобразования
    поступает блок 16 бит, который делится на 4 части по 4 бита.
    
    \end{example}

    \subsubsection{Линейное L-преобразование}

    Линейное преобрзование $L$ представляет собой 16 последовательных применений более
    простого линейного преобразования R, таким образом $L = R^{16}$. Можно подумать,
    что это бессмысленная операция, так как 16 последовательных линейных
    преобразований можно привести к одному применению линейного преобразования с 
    соответсвующими коэффициентами.

    \begin{example}
        Пусть $f_1(x) = k_1 x + b_1$ и $f_2(x) = k_2 x + b_2$. Пусть $y = f_1(f_2(x))$,
        тогда можно последовательное применений функций $f_1$ и $f_2$ заменить 
        применением одной линейной функции $F = K x + B$, где $K = k_1 k_2$ и $B = k_1 b_2 + b_1$.
    \end{example}

    Однако, в нашем случае все немного сложнее, подход $L = R^{16}$ имеет смысл по 
    следующей причине: линейное преобразование $R$ представляет блок входных данных
    длинной 128 бит, как 16 8-битных чисел, которые, в свою очередь, являются начальными
    значениями регистра сдвига. Далее, начальные значения регистра сдвига умножаются на 
    16 заранее известных констант и складыватся, образуя новое значение ячейки регистра 
    сдвига. После 16 итераций в ячейках регистра сдвига мы получим 16 новых чисел, 
    которые представляются в бинарном виде и вместе образуют 128 бит выхода линейного
    преобразования L.

    Приведем пример. \textbf{Внимание! Для удобства читателя в примерах все математические операции выполняются над полем целых чисел. В реальном алгоритме шифрования математические операции проводятся в поле Галуа $\mathbb{GF}(2^8)$ с модулем $p(x) = x^8 + x^7 + x^6 + x + 1$. В таком поле сложение производится по модулю 2, а умножение по модулю многочлена $p(x)$}

    \begin{example}
        
    \end{example}
    
    \section{RISC-V}

    \subsection{Мотивация}

    \textbf{RISC-V} ~---~ расширяемая и открытая система команд, а так же процессорная архитектура
    на основе концепции \textbf {RISC}\footnote{Концепция RISC заключается в малом количестве инструкций
    архитектуры, что позволяет ускорить расшифрование инструкций и исполнение всей программы в целом}.
    RISC-V архитектура появилась лишь в 2010 году и является одной из самых перспективных тем для изучения
    прямо сейчас. Основными преимуществами RISC-V архитектуры являются:

    \begin{enumerate}
        \item \textbf{Простота.} Как уже сказано ранее, RISC-V подчиняется философии RISC, так что
        система команд много меньше, чем у уже существующих архитектур.
        \item \textbf{Модульная структура с поддержкой расширяемости и специализации}
        \begin{enumerate}
            \item Небольшой базовый набор команд с набором стандартных расширений.
            \item Разумное управление кодирование команд, существенное резервирование.
        \end{enumerate}
        \item \textbf{Стабильность}
        \begin{enumerate}
            \item Базовый набор и стандартные расширения уже зафиксированы.
            \item Добавление функционала через расширения, а не через выпуск новых версий.
        \end{enumerate}
        \item \textbf{Открытый доступ и свободное использование}
    \end{enumerate}

    В данной работе мы опустим подробности RISC-V архитектуры и не будем рассказывать про базовый набор
    команд, сжатые инструкции и процесс добавления новых инструкций, но нас будет интересовать векторное
    расширение.

    \subsection{Векторное расширение}

    \textbf {SIMD (single instruction, multiple data)} ~---~ принцип компьютерных вычислений, описывающий
    параллелизм на уровне конвеера процессора. Как уже понятно из названия ~---~ SIMD инструкции позволяют
    обрабатывать не одну ячейку данных, а сразу несколько.

    Наиболее распространенной архитектурой в мире является x86, разработанная компанией Intel. Рассмотрим
    следующий пример:

    \begin{lstlisting}
        int find(const int *a, int n, int x) {
            int i;
            for (i = 0; i < n; i++)
                if (a[i] == x)
                    return i;
            return -1;
        }
    \end{lstlisting}

    Функция выше ищет индекс первого элемента, совпадающий по значению с аргументом $x$. Мы итерируемся
    по всему массиву, постоянно сравнивая элемент под индексом $i$ с искомым $x$. Данный алгоритм является
    довольно простым и имеет линейную асимптотику $O (N)$. При анализе данного подхода естественным желанием
    является его оптимизация: хотелось бы иметь возможность проверять не по одному числу, а несколько чисел
    сразу. SIMD инструкции позволяют это сделать, таким образом, векторизованная версия будет выглядеть
    следующим образом:

    \begin{lstlisting}
        int find_simd(const int *a, int n, int x) {
            if (n >= 16 && __builtin_cpu_supports("avx512f")) {
                __m512i needle = _mm512_set1_epi32(x);
                for (int i = 0; i < (n / 16) * 16; i += 16) {
                    __m512i current = _mm512_loadu_si512(a + i);
                    __mmask16 m =
                        _mm512_cmp_epi32_mask(needle, current, _MM_CMPINT_EQ);
                    if (m != 0)
                        return i + __builtin_ctz(m);
                }
            }
        // дальше обработка хвоста
    \end{lstlisting}

    Функция выше написана с применением SIMD инструкций x86 архитектуры: переменная $__m512i needle$ хранит массив
    значений $x$ и состоит из $16$ элементов размером в $32$ бита, в переменную $__m512i current$ загружается $512$
    бит по адресу $a + i$, затем в $__mmask16 m$ записывается маска, вычисленная с предикатом $_MM_CMPINT_EQ$, который
    сравнивает поэлементно два вектора ($needle$ и $current$). Итоговые замеры производительности:
    
    %TODO: put image here.
    
    Подводя итог можно сделать однозначный вывод: от векторизации нашей программы мы выигрываем по времени в разы. Тем
    не менее, у данного подхода есть и минусы; перечислим их:

    \begin{enumerate}
        \item Потеря читабельности кода и, как итог, скорость разработки проекта замедляется и появляется проблема его
        масштабирования.
        \item Большой проблемой остается обработка "хвоста" массива в случаях, когда его размер не кратен размеру
        используемых регистров. Обработка такого хвоста в большинстве случаев остается линейной.
    \end{enumerate}

    Помимо этого стоит так же отметить, что архитектура x86 имеет огромный набор инструкций: при каждом последующем
    расширении возможностей архитектуры устаревшие инструкции остаются (ради \textit {обратной совместимости}). Возвращаясь
    к теме, RISC-V архитектура пошла по другому пути: каждые новые команды добавляются новыми расширениями, а не обновлением
    уже существующих.

    %TODO что-то про регистры...
    %RISC-V архитектура имеет $32$ векторных регистра $v0, v1, \ldots, v31$, каждый из которых \textit{некоторой} длины $VLEN$.

    %TODO масштабируемая векторизация?

\end{document}