\documentclass[a4paper, 12pt]{article}

\input{./include/preambule.tex}

\begin{document}
    \input{./include/title.tex}

    \section{Abstract}
    Для современных компьютерных систем важно, чтобы алгоритмы шифрования данных были не
    только надежными, но так же быстрыми с точки зрения вычислительных операций. В
    данной статье мы опишем векторную реализацию блочного шифра <<Кузнечик>> для 
    процессорной архитектуры RISC-V, а так же сравним скорость ее работы с 
    последовательной реализацией и векторной реализацией на других архитектурах.

    \section{Введение}

    В современном мире, где довольно значительную роль играют цифровые технологии,
    криптография является довольно важной частью обеспечения безопасности в цифровой
    среде. Защита интернет-соединений и каналов связи, надежность проведения банковских
    операций, подтверждение подлинности электронных документов. Современные методы
    защиты информации накладывают большое количество требований на современные 
    алгоритмы шифрования, такие как теоретическая и вычислительная криптостойкость, а 
    так же скорость работы.
    
    Для современных компьютерных систем важно, чтобы алгоритмы шифрования данных были не
    только надежными, но так же быстрыми с точки зрения вычислительных операций. На 
    сегодняшний день одним из популярных способов увеличения скорости работы программ
    является векторизация математических операций. Данный способ основывается на 
    принципе компьютерных вычислений SIMD (анг. single instruction multiple data), 
    позволяющем обеспечить параллелизм на уровне данных. И хотя, данный вид
    оптимизации требует индивидуальной реализации для разных архитектур, он является
    довольно мощным в плане увеличения производительности кода. Кроме того, векторизацию
    удобно использовать в алгоритмах с большим количеством однотипных математических
    операций, в частности, в алгоритмах блочного шифрования.

    В данной статье мы опишем векторную реализацию блочного шифра <<Кузнечик>> для 
    процессорной архитектуры RISC-V, а так же сравним скорость ее работы с 
    последовательной реализацией и векторной реализацией на других архитектурах.

    \section{Шифр <<Кузнечик>>}

    Алгоритм шифрования <<Кузнечик>> является одним из двух шифров, принятых в 2015 г.
    в России в стандарт блочного шифрования ГОСТ Р 34.12-2015. <<Кузнечик>> относится
    к типу блочных симметричных шифров; это значит, что для зашифрования и
    расшифрования используется один и тот же ключ, и что при шифровании исходный текст
    разделяется на блоки фиксированной длины, каждый из которых шифруется отдельно.

    На сегодняшний день, шифр все еще считается криптостойким.

    \section{Математическое описания шифра <<Кузнечик>>}

    
    \section{RISC-V}

    \subsection{Мотивация}

    \textbf{RISC-V} ~---~ расширяемая и открытая система команд, а так же процессорная архитектура
    на основе концепции \textbf {RISC}\footnote{Концепция RISC заключается в малом количестве инструкций
    архитектуры, что позволяет ускорить расшифрование инструкций и исполнение всей программы в целом}.
    RISC-V архитектура появилась лишь в 2010 году и является одной из самых перспективных тем для изучения
    прямо сейчас. Основными преимуществами RISC-V архитектуры являются:

    \begin{enumerate}
        \item \textbf{Простота.} Как уже сказано ранее, RISC-V подчиняется философии RISC, так что
        система команд много меньше, чем у уже существующих архитектур.
        \item \textbf{Модульная структура с поддержкой расширяемости и специализации}
        \begin{enumerate}
            \item Небольшой базовый набор команд с набором стандартных расширений.
            \item Разумное управление кодирование команд, существенное резервирование.
        \end{enumerate}
        \item \textbf{Стабильность}
        \begin{enumerate}
            \item Базовый набор и стандартные расширения уже зафиксированы.
            \item Добавление функционала через расширения, а не через выпуск новых версий.
        \end{enumerate}
        \item \textbf{Открытый доступ и свободное использование}
    \end{enumerate}

    В данной работе мы опустим подробности RISC-V архитектуры и не будем рассказывать про базовый набор
    команд, сжатые инструкции и процесс добавления новых инструкций, но нас будет интересовать векторное
    расширение.

    \subsection{Векторное расширение}

    \textbf {SIMD (single instruction, multiple data)} ~---~ принцип компьютерных вычислений, описывающий
    параллелизм на уровне конвеера процессора. Как уже понятно из названия ~---~ SIMD инструкции позволяют
    обрабатывать не одну ячейку данных, а сразу несколько.

    Наиболее распространенной архитектурой в мире является x86, разработанная компанией Intel. Рассмотрим
    следующий пример:

    \begin{lstlisting}
        int find(const int *a, int n, int x) {
            int i;
            for (i = 0; i < n; i++)
                if (a[i] == x)
                    return i;
            return -1;
        }
    \end{lstlisting}

    Функция выше ищет индекс первого элемента, совпадающий по значению с аргументом $x$. Мы итерируемся
    по всему массиву, постоянно сравнивая элемент под индексом $i$ с искомым $x$. Данный алгоритм является
    довольно простым и имеет линейную асимптотику $O (N)$. При анализе данного подхода естественным желанием
    является его оптимизация: хотелось бы иметь возможность проверять не по одному числу, а несколько чисел
    сразу. SIMD инструкции позволяют это сделать, таким образом, векторизованная версия будет выглядеть
    следующим образом:

    \begin{lstlisting}
        int find_simd(const int *a, int n, int x) {
            if (n >= 16 && __builtin_cpu_supports("avx512f")) {
                __m512i needle = _mm512_set1_epi32(x);
                for (int i = 0; i < (n / 16) * 16; i += 16) {
                    __m512i current = _mm512_loadu_si512(a + i);
                    __mmask16 m =
                        _mm512_cmp_epi32_mask(needle, current, _MM_CMPINT_EQ);
                    if (m != 0)
                        return i + __builtin_ctz(m);
                }
            }
        // дальше обработка хвоста
    \end{lstlisting}

    Функция выше написана с применением SIMD инструкций x86 архитектуры: переменная $__m512i needle$ хранит массив
    значений $x$ и состоит из $16$ элементов размером в $32$ бита, в переменную $__m512i current$ загружается $512$
    бит по адресу $a + i$, затем в $__mmask16 m$ записывается маска, вычисленная с предикатом $_MM_CMPINT_EQ$, который
    сравнивает поэлементно два вектора ($needle$ и $current$). Итоговые замеры производительности:
    
    %TODO: put image here.
    
    Подводя итог можно сделать однозначный вывод: от векторизации нашей программы мы выигрываем по времени в разы. Тем
    не менее, у данного подхода есть и минусы; перечислим их:

    \begin{enumerate}
        \item Потеря читабельности кода и, как итог, скорость разработки проекта замедляется и появляется проблема его
        масштабирования.
        \item Большой проблемой остается обработка "хвоста" массива в случаях, когда его размер не кратен размеру
        используемых регистров. Обработка такого хвоста в большинстве случаев остается линейной.
    \end{enumerate}

    Помимо этого стоит так же отметить, что архитектура x86 имеет огромный набор инструкций: при каждом последующем
    расширении возможностей архитектуры устаревшие инструкции остаются (ради \textit {обратной совместимости}). Возвращаясь
    к теме, RISC-V архитектура пошла по другому пути: каждые новые команды добавляются новыми расширениями, а не обновлением
    уже существующих.

    %TODO что-то про регистры...
    %RISC-V архитектура имеет $32$ векторных регистра $v0, v1, \ldots, v31$, каждый из которых \textit{некоторой} длины $VLEN$.

    %TODO масштабируемая векторизация?

\end{document}